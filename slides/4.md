## React
<!-- .slide: data-background="images/lego.jpg" -->

--

### 简介

React 是 Facebook 推出的一个用来构建用户界面的 JavaScript 库

- 库，而不是框架
- 专注于UI，相当于MVC中的V
- 组件化开发 && JSX 声明式语法
- 虚拟DOM，高效渲染
- 单向数据流
- 丰富的生态系统：Redux/Router/React Native...


Note: React 起源于 Facebook 的内部项目，Facebook的工程师对市场上所有 JavaScript MVC 框架都不满意，认为传统的MVC模式已经不适用于构建这种大规模应用，因为当系统中的模型和对应的视图越来越多时，其复杂程度就会迅速扩大，加之可能存在的双向数据流动，导致程序难以理解和调试。就决定自己写一套，用来架设 Instagram 的网站。做出来以后，发现这套东西很好用，就在2013年5月开源了

--

### 组件化

<img src="images/com.png" style="background:#fff"/>

Note: React把用户界面抽象成一个个组件，如按钮组件、对话框组件、日期组件。每个组件只关心自己部分的逻辑，通过引入 JSX 语法组合这些组件，最终得到功能丰富、可交互的页面。而且组件复用变得非常容易，同时也能保证组件结构清晰。我们写的 React 代码绝大部分都是在做 React 组件的开发。开发应用程序就像是在玩乐高搭积木

--

评论框例子

![](images/components.png)

--

组件结构

```
<CommentBoxComponent>
	<CommentListComponent>
		<CommmentItemComponent>
			...
			<ButtonComponent/>
		</CommmentItemComponent>
		<CommmentItemComponent>
			...
			<ButtonComponent/>
		</CommmentItemComponent>
	</CommentListComponent>
	<FormBoxComponent>
	</FormBoxComponent>
</CommentBoxComponent>
```

Note:声明式语言的好处是当数据（状态）变化时，React内部知道该怎样去局部更新需要变化的部分视图。也就是说在在编程时我们只需要告诉React想要的是什么，而不需要告诉React怎么样一步步Dom操作才能到达需要的效果。这就是声明式和命令式编程的区别

--

如何创建组件

```
import React from 'react'
import { render } from 'react-dom'

class Component extends React.Component {
  constructor() {
    super();
    this.state = {
    //组件状态
    };
  }
  
  static defaultProps = {
    //组件属性    
  }
  
  handleClick() {
  	alert('click')
  }
  
  render() {
    return <div onClick={this.handleClick}>Click</div>
  }
}

// 加载组件到 DOM 元素 mountNode
render(<Component/>, mountNode)

```

Note: 创建组件的原则，1、单一职责，一个组件应该只做一件事情,当你发现在一个组件做了太多事情的时候，应该考虑将其拆分为更小的子组件，2、根据数据模型拆分组件，因为React是基于数据来渲染UI，所以让你的组件仅仅是用来表现数据模型的某个部分就可以了。3、构建纯组件，一个纯组件通常没有内部状态（state，后面会讲到），它用来渲染的数据完全来自于输入的props，使用相同的props来渲染相同的纯组件多次将得到相同的UI，不存在内部状态导致渲染不同

--

### JSX

类似 xml 的语法，用来描述组件树

```
import React from 'react'

const names = ['Alice', 'Emily', 'Kate']

class HelloMessage extends React.Component {
  
  render() {
    return (
      <div>
	  {
	    names.map((name,i) => {
	      return 
	      <div key={i}
	      	className="red"
	      	style={{marginTop:10}}
	      	onClick={this.handleClick}>Hello, {name}</div>
	    })
	  }
  	</div>
	) 
  }
}

```

Note: 上面代码体现了JSX的基本语法规则：遇到HTML标签，以 < 开头），就用HTML规则解析；遇到代码块（以 { 开头），就用 JavaScript规则解析。注意事项：1、React组件名首字母必须大写，2、最外层的标签只能有一个，如果有多个可以用div标签将其包裹起来，3、和html语法不太一样，属性名不能和js关键字冲突，例如：className,htmlFor，必须是驼峰命名，4、循环创建多个同类子组件的时候，要带上key属性，且key值是唯一的

--

JSX只是一种语法糖

![](images/jsx.jpg)

--

### 组件属性 Props

父组件可以传递属性给子组件，传递方法和HTML中一样

- this.props: 获取属性值
- getDefaultProps: 获取默认属性对象
- this.props.children：子节点属性
- propTypes: 属性类型检查

> ```<Person name="小明" gender="男"/>```

Note:如果把人比作一个组件的话，我们可以从多个方面来描述这个人，比如姓名、年龄、身高、体重等，这些描述中有些是与生俱来的，比如姓名、性别等，在出生的时候父母就定好了，这就叫做属性props。而有些是可以随着时间发生改变的，比如身高体重等，这些就叫做状态。组件的属性是只读的，不能够在组件内部修改，只能由父组件调用的时候决定

--

### 组件状态 State

组件可以存储自己的当前状态，状态会随时间而变化

- this.state：组件的当前状态
- getInitialState：获取组件的初始状态
- this.setState：修改状态

> 状态在组件内部维护，属性由外部控制

Note:做web应用其实是在跟状态打交道，比如菜单的展开和折叠、我们可以把一个组件看做一个状态机, 每一种状态对应于组件的一种ui。由数据驱动UI，当底层数据变了，React会自动处理所有用户界面的更新。我们仅仅表达出你的应用在任意时间点应该呈现的样子,这种展现是可以预测的，给编写测试代码带来了极大的便利

--

### 单向数据流

数据流动的方向按组件的层级自上向下

<img src="images/danxiang.png" style="background:#fff"/>

Note:这种单向数据流比双向数据绑定的方式更适合复杂应用程序。双向数据绑定中如果发现绑定的数据发生变化则会立刻触发重渲染，而无论当前是否处于渲染流程中，这一点也就导致了网页重排与重绘的性能表现非常差。

--

### 组件的生命周期

![](images/reactjs_component_lifecycle.png)

Note:人有生老病死，组件也有生命周期。Mounting：已插入真实DOM，Updating：正在被重新渲染，Unmounting：已移出真实 DOM，React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数

--

### Virtual Dom

--

产品上线时

![](images/app1.jpg)

Note:传统 web app 和 DOM 直接交互，由App来控制DOM的构建和渲染、元素属性的读写、事件的注册和销毁等等。 当新产品刚上线的时候，这种做法看起来也挺好。但随着产品功能越来越丰富、代码量越来越多、开发团队人员越来越多，问题就会暴漏出来

--

一个月以后

![](images/app2.jpg)

Note:你的代码可能会变成这样。当然，合理的代码规划能够避免这类问题，但团队里难免会有擅长屠宰式编程的同学，分分钟把你代码改的面目全非。

--

Virtual Dom

![](images/vd.jpg)

Note:React之所以性能很高，最主要的原因是引入了虚拟dom。真实页面对应一个 DOM 树。在传统页面的开发模式中，每次需要更新页面时，都要手动操作 DOM 来进行更新, 而DOM 操作非常昂贵，而且这部分代码会让整体项目的代码变得难以维护。React在应用和真实 DOM之间加入了一层，也就是 Virtual DOM，虚拟dom会把所有对dom的修改合并计算差异，只对变化的部分进行批量修改

--

Diff 算法

![](images/diff.jpg)

--

一次学习，到处挖坑

![](images/learn.jpg)

- [react native](https://facebook.github.io/react-native/)
- <a target="_blank" href="http://electron.atom.io/apps/">electron</a>

Note:有了组件这层抽象，React 把代码和真实渲染目标隔离开来，除了可以在浏览器端渲染到 DOM 来开发网页外，还能用于开发原生移动应用。可以做web开发，移动端开发，桌面开发

--

### 路由管理

```
import React from 'react'
import { render } from 'react-dom'
import { Router, Route, Link } from 'react-router'

const App = React.createClass({
  render() {
    return (
      <div>
        <h1>App</h1>
        <ul>
          <li><Link to="/about">About</Link></li>
          <li><Link to="/inbox">Inbox</Link></li>
        </ul>
        {this.props.children}
      </div>
    )
  }
})

const About = React.createClass({
  render() {
    return <h3>About</h3>
  }
})

const Inbox = React.createClass({
  render() {
    return (
      <div>
        <h2>Inbox</h2>
        {this.props.children || "Welcome to your Inbox"}
      </div>
    )
  }
})

const Message = React.createClass({
  render() {
    return <h3>Message {this.props.params.id}</h3>
  }
})

render((
  <Router>
    <Route path="/" component={App}>
      <Route path="about" component={About} />
      <Route path="inbox" component={Inbox}>
        <Route path="messages/:id" component={Message} />
      </Route>
    </Route>
  </Router>
), document.body)
```

--

### 状态管理Redux


Note:React 只是 DOM 的一个抽象层，并不是 Web 应用的完整解决方案。也就是说，只用 React 没法写大型应用。为了解决这个问题，2014年 Facebook 提出了 Flux 架构的概念，引发了很多的实现。2015年，Redux 出现，将 Flux 与函数式编程结合一起，很短时间内就成为了最热门的前端架构。

--

![](images/redux.jpg)

Note:Reudx最大的特点是把所有的状态保存在一个地方Store里面，store相当于前端的数据库。Redux 规定， 一个 State对应一个View。只要state相同，View 就相同。State变化，会导致View变化。但是用户接触不到State，只能接触到View。所以State的变化必须是View导致的。Action就是 View 发出的通知，表示 State 应该要发生变化了。store.dispatch()是 View 发出 Action 的唯一方法。Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer

--

### React、Vue、Angular对比

<table>
	<thead>
		<tr>
			<th>产品</th>
			<th>服务端</th>
			<th>体积</th>
			<th>体验</th>
			<th>生态</th>
			<th>上手</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>React</td>
			<td>支持</td>
			<td>50k</td>
			<td>掌握JSX语法和组件封装</td>
			<td>最活跃</td>
			<td>中等</td>
		</tr>
		<tr>
			<td>Vue</td>
			<td>可能会支持</td>
			<td>74k</td>
			<td>基本的HTML/CSS/JS</td>
			<td>其次</td>
			<td>容易</td>
		</tr>
		<tr>
			<td>Angular2</td>
			<td>号称会支持</td>
			<td>500k+</td>
			<td>未体验过</td>
			<td>很低</td>
			<td>难</td>
		</tr>
	</tbody>
</table>


Note:Angular存在的问题，1、太重。2、google喜欢断崖式的升级，1.0-1.2不兼容。 3、双向数据绑定是把双刃剑，angular是基于脏检查，在作用域中的任何操作都会触发脏检查，当你在scope上绑定的模型多了会影响性能。4、由于 ES6 的发布, 使得它的依赖注入特性成为鸡肋。5、对组件化支持的蹩脚实现( 能支持是一回事, 好用是另一回事 ), 而组件化则学习成本过高, 过于复杂, 所以 AngularJS 决定推翻设计重新开发第二版, 而第二版过于激进的采用 Typescript, 完全不兼容的第一版的设计, 以及各种魔法的应用, 使得它离前端越走越远

--

### 第三方组件库

- <a target="_blank" href="http://www.material-ui.com/">Material-UI</a>
- <a target="_blank" href="https://ant.design/?locale=zh-CN">ANT DESIGN</a>